The code that was regularly used included git status and git diff, both to check the status of the working directory and to see if team members had made changes to the script. At the start of the project, we used git init to initialize the project and create a GitHub repository. We also used git log to check the Git history of our project, and git rm <> to remove files. This was useful when testing our code—if a file didn’t contain relevant information or features, team members would use git rm on it or save it for later in case it still contained necessary code. I needed to use git mv, which renames a file, because I originally named my script “OrderBurger” when it should have been “OrderBurgerMain.” When team members created branches, the git branch command was used, and git checkout was frequently used to check the status of branches and specific commits.

The biggest challenge was integrating our code because the code for BurgerOrder was in Node.js, while the code for the website was in HTML and CSS. These languages can work well together, as you can use <style> and implement JavaScript code, but this was an initial concern until we found a solution. We also had some issues with the website because we couldn’t initially decide whether to keep the HTML and CSS in the same file or in two different ones. We ultimately chose two separate files to make the code more structured.

At first, we weren’t sure how to implement the code since JavaScript, HTML, and CSS are different languages, though all designed for building websites. They each have different syntax. We found a solution by writing <style> and then implementing the JavaScript code with the HTML code.

Configuration management is used to track changes in project environments, software, or systems, ensuring that code or settings are consistent and up to date, which reduces the risk of problems later in the project and facilitates collaboration. By using configuration management, you can avoid the mistake of running different software versions in different environments. The most common workflow in GitHub is undoubtedly a branch-based system where everyone contributes relevant and updated commits. Using Git made things easier, as Git supports a branch-based system and having a shared codebase allowed us to collaborate and update our projects through commits. The branch system also helped isolate development tracks with the help of git log and git branch. As we worked on GitHub, merge issues arose because everyone had different versions of the programs, and several people were working on the same file. It was also difficult to keep track of the correct configuration files since they all had different versions. We resolved merge conflicts by manually merging and committing after carefully reviewing the versions of the files. We also learned that collaboration and communication are essential, especially in terms of how much you commit and what changes you make, as these can have a significant impact on the project's outcome. We could have also implemented more code reviews to catch errors before committing. Documenting processes is also important so that everyone understands what is happening in the program when downloading different commits. Merge conflicts were a recurring issue because we didn’t have consistent syntax across the programs, and this problem only grows in larger projects if it isn’t addressed promptly. Everyone must have the correct and same version of the programs for the code to work as a whole. Managing different environments was also a challenge.

The MenuStore database stores all available item types and their attributes. Each item type must include the following information: a unique identifier for each item type, name of the item, a short description of the item, the cost of the item a list of ingredients, the status indicating whether the item is available or out of stock, the type of the item, a link to an image representing the item in the web interface.
 
